"""
```Julia
F( l::Int, m::Int, n::Int )
```
This function evaluates the kinetic terms of the Wannier equation.

See Eq.(C7) in Ref: A. Ceferino, KW Song, et al, Phys. Rev. B 101, 245432 (2020). 
                    https://doi.org/10.1103/PhysRevB.101.245432  

```
"""
F( l, m, n)=sum([ sum([ (l+m-2*(r+s))==n ? sqrt(factorial(n)/(2^(2*r+l)*factorial(m)))*binomial(m,Int((l+m-n)/2)-r)*
            factorial(l)/(factorial(r)*factorial((Int((l-m+n)/2)-r))) : 0 
            for s in 0:minimum([m,l-2r])]) for r in 0:Int(floor(l/2))])

"""
```Julia
HT( Ind::Vec, Nmax::Int, V12::Function, V13::Function, V23::Function, m1::Float, m2::Float, mh::Float, Qx::Float, Qy::Float, lambda1::Float, lambda2::Float )
```
Construction of trion Hamiltonian.

Input:

Ind   = a vector of index that is generated by fTind( Nmax)
Nmax  = cutoff parameter that determines the size of the basis set (see fTind)
m1,m2 = masses for the two particles with SAME charges. 
mh    = mass for the particle with charges different from m1, m2 particles.  [in the unit of free electron mass]
V12   = interaction between the particles with mass m1 and mass m2
V13   = interaction between the particles with mass m1 and mass mh
V23   = interaction between the particles with mass m2 and mass mh
Qx,Qy = Trion total momentum [ Ang^{-1} ]
lambda1, lambda2=  basis length need to be optimized by bound state energy (see README.md) 

Returns: 

NxN Matrix{Float} (trion Hamiltonian), where N is the total number of basis.

```
"""

function HT(Ind, Nmax, V12, V13, V23, m1, m2, mh, Qx, Qy, lambda1, lambda2)
   Nind=length(Ind)
   H=zeros(Nind,Nind)
   k0=13.605692*2*0.529177/(2*pi)^2
   t1=(1/lambda1)
   t2=(1/lambda2)
   lbar=sqrt(lambda1^2+lambda2^2)
   l1=lambda1/lbar
   l2=lambda2/lbar
   KE(t,mc,Q,m,n)=t*(t*(1/mc+1/mh)/2*F(2,m,n)-(Q/mh)*F(1,m,n))
   g(m,n,s,lambda)=(lambda)^(n-s)*(-lambda)^(m-s)*binomial(n,s)*binomial(m,s)*(2^(s-(n+m)/2)*factorial(s)/(sqrt(factorial(m))*sqrt(factorial(n))))#*exp(s*log(2)+log(factorial(s))-1/2*((n+m)*log(2)+log(factorial(m)+log(factorial(n)))))
   # W12=W(V12,0.25,lbar,Nmax)
   # W13=W(V13,0.25,lambda1,Nmax)
   # W23=W(V23,0.25,lambda2,Nmax)
   W12=Wp(V12,0.25*lbar^2,Nmax)
   W13=Wp(V13,0.25*lambda1^2,Nmax)
   W23=Wp(V23,0.25*lambda2^2,Nmax)
   for i in 1:Nind
      for j in i:Nind
         n=Ind[i]
         m=Ind[j]
         #kinetic terms
         h0=((n==m ? (Qx^2+Qy^2)/(2*mh) : 0) 
         + (n[1:3]==m[1:3] ? KE(t2,m2,Qy,m[4],n[4]) : 0) 
         + (n[1:2]==m[1:2] && n[4]==m[4] ? KE(t2,m2,Qx,m[3],n[3]) : 0) 
         + (n[3:4]==m[3:4] && n[1]==m[1] ? KE(t1,m1,Qy,m[2],n[2]) : 0) 
         + (n[2:4]==m[2:4] ? KE(t1,m1,Qx,m[1],n[1]) : 0)
         + (n[1]==m[1] && n[3]==m[3] ? t1*t2/mh*F(1,m[2],n[2])*F(1,m[4],n[4]) : 0 )
         + (n[2]==m[2] && n[4]==m[4] ? t1*t2/mh*F(1,m[1],n[1])*F(1,m[3],n[3]) : 0 ) )
         #interacting terms
         sm=map(minimum, [vcat(n,m)[:,k] for k in 1:length(n)])
         b=m+n
         hint = sum([
            sum([
               sum([
                  sum([
                     # ((b[1]+b[3])%2==0 && (b[2]+b[4])%2==0 ? 1/lbar*W12[b[1]+b[3]-2*(s1+s3)+1,b[2]+b[4]-2*(s2+s4)+1]*g(m[1],n[1],s1,l1)*g(m[2],n[2],s2,l1)*g(n[3],m[3],s3,l2)*g(n[4],m[4],s4,l2) : 0) 
                     ((b[1]+b[3])%2==0 && (b[2]+b[4])%2==0 ? W12[b[1]+b[3]-2*(s1+s3)+1,b[2]+b[4]-2*(s2+s4)+1]*g(m[1],n[1],s1,lambda1)*g(m[2],n[2],s2,lambda1)*g(n[3],m[3],s3,lambda2)*g(n[4],m[4],s4,lambda2) : 0) 
                  for s1 in 0:sm[1]]) 
               for s2 in 0:sm[2]])
            for s3 in 0:sm[3]])
         for s4 in 0:sm[4]])

         # hint += sum([sum([-(n[1]==m[1] && n[2]==m[2] && b[3]%2==0 && b[4]%2==0 ? 1/lambda2*W23[b[3]-2*s3+1,b[4]-2*s4+1]*g(m[3],n[3],s3,1)*g(m[4],n[4],s4,1) : 0) for s3 in 0:sm[3]]) for s4 in 0:sm[4]])
         # hint += sum([sum([-(n[3]==m[3] && n[4]==m[4] && b[1]%2==0 && b[2]%2==0 ? 1/lambda1*W13[b[1]-2*s1+1,b[2]-2*s2+1]*g(m[1],n[1],s1,1)*g(m[2],n[2],s2,1) : 0) for s1 in 0:sm[1]]) for s2 in 0:sm[2]])
         hint += sum([sum([-(n[1]==m[1] && n[2]==m[2] && b[3]%2==0 && b[4]%2==0 ? W23[b[3]-2*s3+1,b[4]-2*s4+1]*g(m[3],n[3],s3,lambda2)*g(m[4],n[4],s4,lambda2) : 0) for s3 in 0:sm[3]]) for s4 in 0:sm[4]])
         hint += sum([sum([-(n[3]==m[3] && n[4]==m[4] && b[1]%2==0 && b[2]%2==0 ? W13[b[1]-2*s1+1,b[2]-2*s2+1]*g(m[1],n[1],s1,lambda1)*g(m[2],n[2],s2,lambda1) : 0) for s1 in 0:sm[1]]) for s2 in 0:sm[2]])
         
      H[i,j]=h0+k0*hint
      H[j,i]=h0+k0*hint
      end
   end
   return H
end

"""
```Julia
HX( Ind::Vec, Nmax::Int, V::Function, m1::Float, mh::Float, Qx::Float, Qy::Float, lambda::Float )
```
Construction of exciton Hamiltonian.

Input:

Ind   = a vector of index that is generated by fTind( Nmax)
Nmax  = cutoff parameter that determines the size of the basis set (see fXind)
m1 = masses for the two particles with SAME charges. 
mh = mass for the particle with charges different from m1, m2 particles.  [in the unit of free electron mass]
V   = interaction between the particles with mass m1 and mass mh
Qx,Qy  = Trion total momentum [ Ang^(-1) ]
lambda =  basis length need to be optimized by bound state energy (see README.md) 

Returns: 

NxN Matrix{Float} (exciton Hamiltonian), where N is the total number of basis.

```
"""

function HX(Ind, Namx, V, m1, mh, Qx, Qy, lambda)
   Nind=length(Ind)
   H=zeros(Nind,Nind)
   k0=13.605692*2*0.529177/(2*pi)^2
   t=(1/lambda)
   KE(t,mc,Q,m,n)=t*(t*(1/mc+1/mh)/2*F(2,m,n)-(Q/mh)*F(1,m,n))
   g(m,n,s,l)=(l)^(n-s)*(-l)^(m-s)*binomial(n,s)*binomial(m,s)*(2^(s-(n+m)/2)*factorial(s)/(sqrt(factorial(m))*sqrt(factorial(n))))
   # V1=W(V,0.25,lambda,Namx)
   V1=Wp(V,0.25*lambda^2,Namx)
   for i in 1:Nind
      for j in i:Nind
         n=Ind[i]
         m=Ind[j]
         h0=((n==m ? (Qx^2+Qy^2)/(2*mh) : 0) 
         + (n[1]==m[1] ? KE(t,m1,Qy,m[2],n[2]) : 0) 
         + (n[2]==m[2] ? KE(t,m1,Qx,m[1],n[1]) : 0) )

         sm=map(minimum, [vcat(n,m)[:,k] for k in 1:length(n)])
         b=m+n
         # hint=sum([sum([-(b[1]%2==0 && b[2]%2==0 ? 1/lambda*V1[b[1]-2*s1+1,b[2]-2*s2+1]*g(m[1],n[1],s1,1)*g(m[2],n[2],s2,1) : 0) for s1 in 0:sm[1]]) for s2 in 0:sm[2]])
         hint=sum([sum([-(b[1]%2==0 && b[2]%2==0 ? V1[b[1]-2*s1+1,b[2]-2*s2+1]*g(m[1],n[1],s1,lambda)*g(m[2],n[2],s2,lambda) : 0) for s1 in 0:sm[1]]) for s2 in 0:sm[2]])
   
      H[i,j]=h0+k0*hint
      H[j,i]=h0+k0*hint
      end
   end
   return H
end
